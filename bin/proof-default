#!/usr/bin/env node

/*

usage: proof default [options] [<files>...]

  Run tests and display progress a colorized progress meter.

options:

    -d,   --digits    [count]     number of timing digits to display
    -h,   --help                  display this usage information
    -M,   --monochrome            do not display color
    -p,   --processes [count]     number of processes to run
    -w,   --width     [count]     width in characters of progress display

invocation:

  If there are no errors, `proof` exits with a zero exit code, otherwise it
  returns a non-zero exit code.

description:

  `proof` runs a collection of tests and displays a colorful, animated
  report of test progress. Output from `proof run` can be piped to
  `proof progress` to display the progress of a test run as it is
  running. Using a utility like `tee`, you can both pipe `proof run`
  output to `proof progress` and save it to file for later reporting.

:usage

*/

var arguable = require('arguable')
  , options
  , spawn = require('child_process').spawn
  , progress = {}, run = {};

try {
  options = arguable.parse(__filename, 'default', process.argv.slice(2))
} catch (e) {
  console.error('error: ' + e.message);
  console.error(e.usage);
  process.exit(1);
}

if (options.help) {
  console.log(options.$usage);
} else {
  options.$given.forEach(function (name) {
    if ("help" == name) {
      console.log(options.$usage);
    } else if (/^(monochrome|width|digits)$/.test(name)) {
      progress[name] = options[name]; 
    } else {
      run[name] = options[name]; 
    }
  });

  progress = spawn('node', arguable.flatten(__dirname + '/proof', 'progress', progress), { customFds: [ -1, 1, 2 ] });
  run = spawn('node', arguable.flatten(__dirname + '/proof', 'run', run, options.$argv), { customFds: [ -1, -1, 2 ] });
  run.stdout.pipe(progress.stdin);

  progress.on('exit', function (code) { process.exit(code) });
}
